# **3.1 Chrome으로 디버깅하기**

### 디버깅

디버깅은 스크립트 내 에러를 검출해 제거하는 일련의 과정을 의미한다. 모던 브라우저와 호스트 환경 대부분은 개발자 도구 안에 UI 형태로 디버깅 툴을 구비해놓았다. **디버깅 툴을 사용하면 디버깅이 훨씬 쉬워지고, 실행 단계마다 어떤 일이 일어나는지를 코드 단위로 추적할 수 있다.**

### 중단점(Breakpoints)

- 소스 코드 영역의 코드 좌측의 줄 번호를 클릭하면 중단점(break point)을 설정할 수 있다.
- *중단점(breakpoint)*은 말 그대로 자바스크립트의 실행이 중단되는 코드 내 지점을 의미한다.
- 중단점을 이용하면 실행이 중지된 시점에 변수가 어떤 값을 담고 있는지 알 수 있다. 또한 실행이 중지된 시점을 기준으로 명령어를 실행할 수도 있다. 디버깅이 가능해지는 것이다.

Sources 패널 우측의 디버깅 영역을 보면 중단점 목록을 확인할 수 있다. 파일 여러 개에 다수의 중단점을 설정해 놓은 경우, 디버깅 영역을 이용하면 아래와 같은 작업을 할 수도 있다.

- 항목을 클릭해 해당 중단점이 설정된 곳으로 바로 이동할 수 있습니다.
- 체크 박스 선택을 해제해 해당 중단점을 비활성화 할 수 있습니다.
- 마우스 오른쪽 버튼을 클릭했을 때 나오는 ‘Remove breakpoint’ 옵션을 통해 중단점을 삭제할 수도 있습니다.

**조건부 중단점**

줄 번호에 커서를 옮긴 후 마우스 오른쪽 버튼을 클릭하면 *조건부 중단점(conditional breakpoint)* 을 설정할 수 있다. `Add conditional breakpoint`를 클릭했을 때 뜨는 작은 창에 표현식을 입력하면, 표현식이 참인 경우에만 실행을 중지시킨다. 조건부 중단점을 설정하면 변수에 특정 값이 할당될 때나 함수의 매개 변수에 특정 값이 들어올 때만 실행을 중단시킬 수 있다.

### debugger

`debugger` 명령어를 적어주면 중단점을 설정한 것과 같은 효과를 낸다. 덕분에 에디터를 떠나 브라우저를 켜 개발자 도구를 열고 소스 코드 영역을 띄워 중단점을 설정하는 수고를 하지 않아도 된다. 

```jsx
function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- 여기서 실행이 멈춘다.

  say(phrase);
}
```

### 멈추면 보이는 것들

예시 페이지를 열면 함수 `hello()`가 자동으로 호출된다. 중단점이 제대로 설정되어있는지 확인하고, 새로 고침울 눌러 중단점을 작동시키면, 아래 그림과 같이 네 번째 줄에서 실행이 중단되는 것을 확인할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a7dde747-c591-4f5e-a129-6fb848ba50b0/Untitled.png)

이 상태에서 디버깅 영역의 `▼`를 클릭해 하위 패널들을 하나씩 볼 수 있다. 각 패널은 아래와 같은 기능을 제공한다.

1. **`Watch` – 표현식을 평가하고 결과를 보여준다.**
    
     `+`를 클릭해 원하는 표현식을 입력한 후 Enter를 누르면 중단 시점의 값을 보여준다. 입력한 표현식은 실행 과정 중에 계속해서 재평가된다.
    
2. **`Call Stack` – 코드를 해당 중단점으로 안내한 실행 경로를 역순으로 표시한다.**
    
    콜 스택 내의 항목을 클릭하면 디버거가 해당 코드로 휙 움직이고, 변수 역시 재평가된다. 
    
3. **`Scope` – 현재 정의된 모든 변수를 출력한다.**
    
    `Local`은 함수의 지역변수를 보여준다. 지역 변수 정보는 소스 코드 영역에서도 확인(강조 표시)할 수 있습니다. 하위 항목으로 `this`에 대한 정보도 출력된다.
    
    `Global`은 함수 바깥에 정의된 전역 변수를 보여준다.
    
    ### 실행 추적하기
    
    이제 본격적으로 실행 단계마다 어떤 일이 일어나는지 추적해보자.
    
    - Resume: 단축키 `F8`, 실행을 재개, 추가 중단점이 없는 경우, 실행이 이어지고 디버거는 동작하지 않는다.
    - Step: 단축키 `F9`, 다음 문 하나를 실행한다.
    - Step over: `F10`, 다음 명령어를 실행하되, 함수 안으로 들어가지는 않는다. Step과 유사하지만 실행할 문이 직접 작성한 함수 호출인 경우에는 Step과 다르게 동작한다.
        - Step은 함수 내부로 들어가 함수 본문 첫 번째 줄에서 실행을 멈춘다.
        - 반면 Step over는 보이지 않는 곳에서 중첩 함수를 실행하긴 하지만 **함수 내로 진입하지는 않는다.** 즉 함수 호출 시 **내부에서 어떤 일이 일어나는지 관심이 없을 때** 사용한다.
    - Step into: 단축키 `F11`, 비동기 함수 호출에서 Step과 다르게 동작한다.
        - Step은 비동기 동작은 무시한다.
        - 반면 Step into는 비동기 동작을 담당하는 코드로 진입하고, 필요하다면 **비동기 동작이 완료될 때까지 대기**한다.
    - Step out: 단축키 `Shift`+`F11`, 실행 중인 **함수의 실행이 끝날 때까지 실행**을 계속한다.
    - Continue to here: 줄에서 오른쪽 버튼 클릭 후 선택, 해당 줄에서 실행을 재개한다.
    
    ### console.log
    
    원하는 것을 콘솔에 출력할 수 있다. 결과는 콘솔창에만 있기 때문에 일반 사용자는 결과를 볼 수 없다.
    

### 요약

스크립트 실행이 중단되는 경우는 다음과 같다.

1. 중단점을 만났을 때
2. `debugger`문 만났을 때
3. 에러가 발생했을 때(개발자 도구가 열려있고 버튼이 '활성화’되어있는 경우)

스크립트 실행이 중지되면 중단 시점을 기준으로 변수에 어떤 값이 들어가 있는지 확인할 수 있다. 또한 단계별로 코드를 실행해 가며, 어디서 문제가 발생했는지 추적할 수도 있다. 이런 식으로 디버깅이 진행됩니다.

개발자 도구는 이외에도 다양한 기능을 지원한다. [개발자 도구 공식 매뉴얼]([https://developers.google.com/web/tools/chrome-devtools](https://developers.google.com/web/tools/chrome-devtools))에서 확인할 수 있다.

# **3.2 코딩 스타일**

- 질문 목록
    - 가독성이 좋고 이해하기 쉬운 코드를 만들려면 무엇을 해야할까요? 에러를 피하려면 어떻게 해야할까요?
    - 정의한 함수의 끝에 세미콜론을 붙이는가?
    - 호출부를 먼저 쓰고 헬퍼 함수를 나중에 두는 방식의 장점은?
    - 문자열을 여러 줄로 쉽게 나눌 때, 어떤 걸 사용하면 좋을까요?
    - 중첩레벨을 줄이는 자신만의 방법이 있다면?
    - Linter를 왜 사용할까요?

⚠️ 무조건 따라야하는 규칙은 없다. 

### 중괄호

대부분의 자바스크립트 프로젝트에서 여는 중괄호는 ‘이집션(Egyptian)’ 스타일을 따라 새로운 줄이 아닌 상응하는 키워드와 같은 줄에 작성한다. 여기에 더하여 여는 중괄호 앞엔 공백이 하나 있어야 한다. 

```jsx
if (condition) {
  // ...코드 n...
}
```

`if (condition) doSomething()`과 같은 단 한 줄짜리 구문은 중요하게 다뤄야 할 에지 케이스다. 이런 예외상황에도 중괄호를 써야 할까?

코드가 짧다면 중괄호 없이 한 줄에 쓰는 방법도 괜찮다.

```jsx
if (n < 0) alert(`Power ${n} is not supported`);
```

가장 추천하는 방법은 다음과 같다.

```jsx
if (n < 0) {
  alert(`Power ${n} is not supported`);
}
```

### 가로 길이

코드의 가로 길이가 길어진다면 여러 줄로 나눠 작성하는 게 좋다. 대개 80자나 120자로 제한하는 게 일반적이다.

```jsx
// 백틱(`)을 사용하면 문자열을 여러 줄로 쉽게 나눌 수 있습니다.
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;
```

```jsx
// if 문은 이런 식으로 작성할 수 있다. 
if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}
```

### 들여쓰기

들여쓰기에는 두 종류가 있다.

- **가로 들여쓰기: 스페이스 두 개 혹은 네 개를 사용해 만듦**
    
    가로 들여쓰기는 스페이스 두 개 혹은 네 개를 사용하거나 탭 키(Tab)를 이용해 만들 수 있다. 어떤 방법을 쓸지에 대한 논쟁은 오래전부터 있었는데, 요즘엔 탭 대신 스페이스를 이용하는 게 더 우위에 있는 것 같다. 탭 대신 스페이스를 이용했을 때의 장점 중 하나는 들여쓰기 정도를 좀 더 유연하게 변경할 수 있다는 점이다.
    
    ```jsx
    show(parameters,
         aligned, // 스페이스 다섯 개를 이용해 들여쓰기 함
         one,
         after,
         another
      ) {
      // ...
    }
    ```
    
- **세로 들여쓰기: 논리 블록 사이에 넣어 코드를 분리해주는 새 줄**
    
    함수 하나에 논리 블록 여러 개가 들어갈 수 있다. 아래 예시에서 변수 선언, 반복문, 리턴문 사이에 세로 들여쓰기를 해주는 빈 줄을 넣어 코드를 분리한다.
    
    ```jsx
    function pow(x, n) {
      let result = 1;
      //              <--
      for (let i = 0; i < n; i++) {
        result *= x;
      }
      //              <--
      return result;
    }
    ```
    

### 세미콜론

자바스크립트 엔진에 의해 무시되더라도 모든 구문의 끝엔 세미콜론을 써주는 것이 좋다. 구문 끝에 세미콜론을 적는 게 완전히 선택사항인 언어가 몇몇 있는데 이런 언어들에선 세미콜론을 잘 쓰지 않는다. 그러나 자바스크립트에선 줄 바꿈이 세미콜론으로 해석되지 않는 몇몇 상황이 있기 때문에 세미콜론을 생략하고 코딩하는 습관을 들이면 에러를 발생시키는 코드를 만들 수 있다. 자세한 사례는 [코드 구조](https://ko.javascript.info/structure#semicolon) 챕터에.

경험이 많은 자바스크립트 개발자라면 [StandardJS](https://standardjs.com/)에서 제시하는 스타일 가이드처럼 세미콜론 없이 코드를 작성할 수도 있다. 초보 개발자라면 에러를 만들 확률을 줄이기 위해서라도 세미콜론을 사용하는 게 좋다.

### 중첩 레벨

가능하면 너무 깊은 중첩문은 사용하지 않는 것이 좋다. 반복문을 사용할 때 중첩문의 깊이가 깊어지면 `[continue](https://ko.javascript.info/while-for#continue)` 지시자를 쓰는 게 좋은 대안이 될 수도 있다.

```jsx
for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- 중첩 레벨이 하나 더 늘어났다.
  }
}
```

```jsx
for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- 추가 중첩 레벨이 추가되지 않는다.
}
```

`if`/`else`와 `return`문을 조합하면 위 예시와 유사하게 중첩 레벨을 줄여 코드의 가독성을 높일 수 있다.

```jsx
function pow(x, n) {
  if (n < 0) {
    alert("'n'은 음수가 될 수 없습니다.");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}
```

```jsx
function pow(x, n) {
  if (n < 0) {
    alert("'n'은 음수가 될 수 없습니다.");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

`n < 0`인 '특별한 상황’을 앞에 두고, 그 안에 `return`문을 추가하여 가독성을 높였다. 특별한 상황인지를 확인하고 조건을 통과하면 추가 중첩 없이 ‘주요’ 코드 흐름으로 넘어가는 코드를 짰기 때문이다. (Guard Clause)

### 함수의 위치

헬퍼 함수(다른 함수 안에서 특정 기능을 하고 있는 함수)를 여러 개 만들어 사용하고 있다면 아래와 같은 방식으로 정돈할 수 있다.

1. 헬퍼 함수를 사용하는 코드 위에서 함수를 모아 선언하기

```jsx
// 함수 선언
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// 헬퍼 함수를 사용하는 코드
let elem = createElement();
setHandler(elem);
walkAround();
```

1. 코드를 먼저, 함수는 그 다음에 선언하기

```jsx
// 헬퍼 함수를 사용하는 코드
let elem = createElement();
setHandler(elem);
walkAround();

// --- 헬퍼 함수 ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}
```

1. 혼합, 코드 바로 위에서 필요한 헬퍼 함수를 그때그때 선언하기

대개는 두 번째 방법으로 코드를 정돈하는 걸 선호한다. 사람들은 이 코드가 '무엇을 하는지’를 생각하며 코드를 읽기 때문에 코드가 먼저 나오는 것이 자연스럽기 때문이다. 이름만 보고도 헬퍼 함수의 역할을 쉽게 유추할 수 있게 헬퍼 함수 이름을 명명했다면 함수 본문을 읽을 필요도 없다.

### 스타일 가이드

코딩 스타일 가이드는 코드를 '어떻게 작성할지’에 대한 전반적인 규칙을 담은 문서로, 어떤 따옴표를 쓸지, 들여쓰기할 때 스페이스를 몇 개 사용할지, 최대 가로 길이는 몇까지 제한할지 등의 내용이 담겨있다.

팀원 전체가 동일한 스타일 가이드를 따라 코드를 작성하면, 누가 코드를 작성했나에 관계없이 동일한 스타일의 코드를 만들 수 있다.

유명 스타일 가이드:

- [Google의 자바스크립트 스타일 가이드](https://google.github.io/styleguide/jsguide.html)
- [Airbnb의 자바스크립트 스타일 가이드](https://github.com/airbnb/javascript)
- [Idiomatic.JS](https://github.com/rwaldron/idiomatic.js)
- [StandardJS](https://standardjs.com/)

### Linter

Linter라는 도구를 사용하면 내가 작성한 코드가 스타일 가이드를 준수하고 있는지를 자동으로 확인할 수 있고, 스타일 개선과 관련된 제안도 받을 수 있다. 이렇게 자동으로 스타일을 체크받다 보면, 변수나 함수 이름에 난 오타 등이 유발하는 버그를 미리 발견할 수 있다. 아직 '코드 스타일’을 정하지 않았더라도 linter를 사용하면 버그를 예방할 수 있기 때문에 linter 사용은 권유된다.

유명 linter:

- [JSLint](http://www.jslint.com/) – 역사가 오래된 linter
- [JSHint](http://www.jshint.com/) – JSLint보다 세팅이 좀 더 유연한 linter
- [ESLint](http://eslint.org/) – 가장 최근에 나온 linter

### 과제

아래 코드가 어떤 점에서 좋지 않은지 생각해보고, 더 나은 코드로 고쳐보기

```jsx
function pow(x,n)
{
  let result=1;
  for(let i=0;i<n;i++) {result*=x;}
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'')
if (n<=0)
{
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else
{
  alert(pow(x,n))
}
```

- 해답
    
    ```jsx
    function pow(x, n) {
      let result = 1;
      
    	for (let i = 0; i < n; i++) {
    		result *= x;
    	}
      
    	return result;
    }
    
    let x = prompt("x?", ''); 
    let n = prompt("n?", '');
    
    if (n <= 0) {
      alert(`Power ${n} is not supported, 
    please enter an integer number greater than zero`);
    } else {
      alert( pow(x,n) );
    }
    ```
    

# 3.3 주석

## 좋지 않은 주석

좋은 코드엔 ‘설명이 담긴(explanatory)’ 주석이 많아선 안 된다. 

e.g., 

```jsx
// 이 코드는 (...)과 (...)을 수행합니다
// A라는 개발자가 이 기능에 대해 알고 있으며...
very;
complex;
code;
```

주석 없이 코드 자체만으로 코드가 무슨 일을 하는지 쉽게 이해할 수 있어야 한다. 

> 코드가 불분명해서 주석 작성이 불가피하다면 코드를 다시 작성해야 하는 지경에 이른 걸 수 있습니다.
> 

### 리팩토링 팁

1. 함수 분리하기: 함수 내 코드 일부를 새로운 함수로 옮기는 게 유익할 때도 있다. 새로운 함수의 이름이 그 자체로 주석의 역할을 한다. (self-descriptive code)
2. 함수 만들기:  함수는 주석이 없어도 그 존재 자체가 무슨 역할을 하는지 설명할 수 있어야 한다. 코드를 분리해서 작성하면 더 나은 코드 구조가 된다. 

물론 '설명이 담긴' 주석이 불가피한 경우도 있다. 이를테면 알고리즘이 복잡한 코드나 최적화를 위한 코드 비틀기가 필요한 경우 등.

## 좋은 주석

### 아키텍처를 설명하는 주석

고차원 수준 컴포넌트 개요, 컴포넌트 간 상호작용에 대한 설명, 상황에 따른 제어 흐름 등은 주석에 넣는 것이 좋다. 이런 주석은 조감도 역할을 한다. 

고차원 수준의 아키텍처 다이어그램을 그리는 데 쓰이는 UML도 있다.

### 함수 용례와 매개변수 정보를 담고 있는 주석

JSDoc이라는 특별한 문법을 사용하면 함수에 관한 문서를 쉽게 작성할 수 있다. 여기엔 함수 용례, 매개변수, 반환 값 정보가 들어간다. 

e.g.,

```jsx
/**
 * x를 n번 곱한 수를 반환함
 *
 * @param {number} x 거듭제곱할 숫자
 * @param {number} n 곱할 횟수, 반드시 자연수여야 함
 * @return {number} x의 n 거듭제곱을 반환함
 */
function pow(x, n) {
  ...
}
```

### 왜 이런 방법으로 문제를 해결했는지를 설명하는 주석

때로는 "무엇이 적혀있는지" 보다 "무엇이 적혀 있지 않은지"가 더 중요할 수도 있다. 이것이 "왜 이 문제를 그러한 방법으로 해결했는가"에 대한 대답이 되어주기 때문이다. 방법 선택의 이유를 설명해주는 주석은 실수를 방지하는 안내판 역할을 한다.

### 미묘한 기능이 있고, 이 기능이 어디에 쓰이는지를 설명하는 주석

직감에 반하는 미묘한 동작을 수행하는 코드가 있다면 주석을 달아주는 게 좋다.

## 요약

- 잘 작성된 주석은 효율적으로 정보를 전달하고 유지보수에도 도움이 된다.
- 주석에 들어가면 좋은 내용
    - 고차원 수준 아키텍처
    - 함수 용례
    - 당장 봐서는 명확해보이지 않은 해결 방법에 대한 설명
- 들어가면 좋지 않은 내용
    - 코드가 어떻게 동작하는지, 무엇을 하는지에 대한 설명

# 3.4 닌자 코드

- 코드 짧게 쓰기
- 글자 하나만 사용하기
- 약어 사용하기
- 포괄적인 명사 사용하기
    - e.g, data, str, num 등.
- 철자가 유사한 단어 사용하기
- 동의어 사용하기
- 이름 재사용하기
- 재미로 언더스코어 사용하기
- 과장 형용사 사용하기
- 외부 변수 덮어 쓰기
- 부작용이 있는 코드 작성하기
- 함수에 다양한 기능 넣기

# 3.5 테스트 자동화와 Mocha

우리는 무언가를 개발하며 콘솔 창 등을 통해 실제 실행 결과와 기대값이 같은지 계속 비교해가며 구현을 확인한다. 하지만 이렇게 수동으로 코드를 재실행하는 것은 매우 불완전하다. 코드를 수동으로 재실행하며 테스트하면 무언가를 놓치기 쉽다. 하나를 고치면 다른 게 제대로 작동하지 않을 수도 있다.

테스팅 자동화는 테스트 코드가 실제 동작에 관여하는 코드와 별개로 작성되었을 때 가능하다. 테스트 코드를 이용하면 함수를 다양한 조건에서 실행해볼 수 있는데, 이때 실행 결과와 기대 결과를 비교할 수 있다.

## Behavior Driven Development

BDD는 테스트, 문서, 예시를 한데 모아놓은 개념이다.

## 거듭제곱 함수와 명세서

거듭제곱 함수를 구현해보는 예시를 통해 BDD를 적용해보고자 한다.

본격적으로 코드를 작성하기 전에 코드가 무슨 일을 하는지 자연어로 적어야 한다. 이것을 명세서(specification, spec)라 부른다.

```jsx
describe("pow", function() {
  it("주어진 숫자의 n 제곱", function() {
    assert.equal(pow(2, 3), 8);
  });
});
```

스펙은 세 주요 요소로 이루어진다.

`descibe`, `it`, `assert`

## 개발 순서

1. 명세서 초안 작성과 기본적인 테스트
2. 명세서 초안을 보고 코드 작성
3. 코드가 작동하는지 확인(Mocha 등의 테스트 프레임워크 이용), 테스트를 모두 통과해 에러가 더는 출력되지 않을 때까지 코드 수정
4. 모든 테스트를 통과하는 코드 초안 완성
5. 유스케이스 추가 → 테스트 실패하기 시작
6. 3단계로 돌아가 코드 수정
7. 기능이 완성될 때까지 3 ~ 6을 반복

# 3.6 폴리필

변경된 표준을 준수할 수 있게 기존 함수의 동작 방식을 수정하거나, 새롭게 구현한 함수의 스크립트를 **폴리필(polyfill)**이라 부른다. 폴리필은 말 그대로 구현이 누락된 새로운 기능을 메꿔주는(fill in) 역할을 한다.

## 바벨

바벨은 모던 자바스크립트 코드를 구 표준을 준수하는 코드로 바꿔주는 트랜스파일러다.