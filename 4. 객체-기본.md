# 4.1 객체

객체형 자료는 원시형과 달리 다양한 데이터를 담을 수 있다. 키로 구분된 데이터 집합이나 복잡하 개체를 저장할 수 있다. 

자바스크립트에는 일반 객체 이외에도 `Array`, `Date`, `Error` 등 다양한 종류의 객체가 있다. 이들은 독립적인 자료형이 아니라 객체 형에 속한다. 객체에 다양한 기능을 넣어 확장한 또 다른 객체인 것이다.

### 계산된 프로퍼티(computed property)

객체 리터럴 안의 프로퍼티 키가 대괄호로 둘려싸여 있는 경우, 이를 계산된 프로퍼티라 부른다.

```jsx
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

let bag = {
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아온다.
};

alert( bag.apple ); // fruit에 "apple"이 할당되었다면, 5가 출력된다.
```

### 단축 프로퍼티

### 프로퍼티 이름의 제약사항

다른 변수 이름과 달리 객체 프로퍼티엔 자바스크립트의 예약어를 쓰면 안된다는 제약이 없다.

유일한 예외는 `__proto__`다.

### `in` 연산자

자바스크립트 객체의 특징 중 하나는 다른 언어와 달리, 존재하지 않는 프로퍼티에 접근하려 해도 에러 대신 `undefined`를 반환한다는 것이다. 이를 이용해 프로퍼티 존재 여부를 쉽게 확인할 수 있다.

```jsx
let user = {};

alert( user.noSuchProperty === undefined ); // true는 '프로퍼티가 존재하지 않음'을 의미한다.
```

또 다른 방법은 `in` 연산자를 이용하는 것이다.

```jsx
let user = { name: "John", age: 30 };

alert( "age" in user ); // user.age가 존재하므로 true가 출력된다.
alert( "blabla" in user ); // user.blabla는 존재하지 않기 때문에 false가 출력된다.
```

`in`을 이용하면 `undefined` 값이 할당된 경우도 잡아낼 수 있다.

```jsx
let obj = {
  test: undefined
};

alert( obj.test ); // 값이 `undefined`이므로, undefined가 출력된다. 그런데 프로퍼티 test는 존재한다.

alert( "test" in obj ); // `in`을 사용하면 프로퍼티 유무를 제대로 확인할 수 있다. true가 출력된다.
```

### for in 반복문

for in 반복문을 상요하면 객체의 모든 키를 순회할 수 있다.

한편 정수 프로퍼티가 아니라면 프로퍼티들은 추가 순서대로 정렬되어 있다. (정수는 오름차순으로 자동 정렬된다.)

- 과제
    
    Q. 다음 각 동작을 한 줄씩, 코드로 작성해보세요.
    
    1. 빈 객체 `user`를 만듭니다.
    2. `user`에 키가 `name`, 값이 `John`인 프로퍼티를 추가하세요.
    3. `user`에 키가 `surname`, 값이 `Smith`인 프로퍼티를 추가하세요.
    4. `name`의 값을 `Pete`로 수정해보세요.
    5. `user`에서 프로퍼티 `name`을 삭제하세요.
    
    A.
    
    ```jsx
    const user = {};
    
    user.name = 'John';
    user.surname = 'Smith;'
    
    user.name = 'Pete';
    
    delete user.name;
    ```
    
    Q.  객체에 프로퍼티가 하나도 없는 경우 `true`, 그렇지 않은 경우 `false`를 반환해주는 함수 `isEmpty(obj)`를 만들어 보세요.
    
    아래와 같이 동작해야 합니다.
    
    ```jsx
    let schedule = {};
    
    alert( isEmpty(schedule) ); // true
    
    schedule["8:30"] = "get up";
    
    alert( isEmpty(schedule) ); // false
    ```
    
    A.
    
    ```jsx
    function isEmpty(obj) {
    	if (!Object.keys(obj).length) {
    		return false;	
    	}
    
    	return true;
    }
    ```
    
    Q. `const`와 함께 선언한 객체를 변경하는 게 가능할까요? 생각을 공유해주세요!
    
    ```jsx
    const user = {
      name: "John"
    };
    // 아래 코드는 에러 없이 실행될까요?
    user.name = "Pete";
    ```
    
    A. `user`를 직접 변경하는 것이 아니라 `user`의 프로퍼티에 접근하는 것이기 때문에 가능하다.
    
    Q. 모든 팀원의 월급에 대한 정보를 담고 있는 객체가 있다고 해봅시다.
    
    ```jsx
    let salaries = {
      John: 100,
      Ann: 160,
      Pete: 130
    }
    ```
    
    모든 팀원의 월급을 합한 값을 구하고, 그 값을 변수 `sum`에 저장해주는 코드를 작성해보세요. `sum`엔 `390`이 저장되어야겠죠?
    
    주의: `salaries`가 비어있다면 `sum`에 `0`이 저장되어야 합니다.
    
    A.
    
    ```jsx
    let sum = Object.values(salaries).reduce((a, b) => a + b, 0);
    ```
    
    Q. 객체 `obj`의 프로퍼티 값이 숫자인 경우 그 값을 두 배 해주는 함수 `multiplyNumeric(obj)`을 만들어보세요.
    
    ```jsx
    // 함수 호출 전
    let menu = {
      width: 200,
      height: 300,
      title: "My menu"
    };
    
    multiplyNumeric(menu);
    
    // 함수 호출 후
    menu = {
      width: 400,
      height: 600,
      title: "My menu"
    };
    ```
    
    `multiplyNumeric`은 아무것도 반환하지 않아도 괜찮습니다. 객체 자체를 수정해주기만 하면 됩니다.
    
    힌트) `typeof`를 사용하면 프로퍼티 값이 숫자인지 확인할 수 있습니다.
    
    A.
    
    ```jsx
    function multiplyNumeric(menu) {
    	for (let key in menu) {
    		if (typeof menu.key === 'number') {
    			menu.key *= 2;
    		}
    	}
    }
    ```
    

# 4.2 참조에 의한 객체 복사

객체와 원시 타입의 근본적인 차이 중 하나는 객체는 참조에 의해 저장되고 복사된다는 것이다.

변수에 객체는 값이 그대로 저장되지 않고, 객체가 저장되어잇는 메모리 주소인 객체에 대한 참조값이 저장된다.

### 객체 복사, 병합과 `Object.assign`

객체 참조가 아니라 객체 자체를 복제하고 싶다면 새로운 객체를 만들고 기존 객체의 프로퍼티들을 순회하며 원시 수준까지 복사해야 한다.

```jsx
let user = {
  name: "John",
  age: 30
};

let clone = {}; // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사해 넣습니다.
for (let key in user) {
  clone[key] = user[key];
}

// 이제 clone은 완전히 독립적인 복제본이 되었습니다.
clone.name = "Pete"; // clone의 데이터를 변경합니다.

alert( user.name ); // 기존 객체에는 여전히 John이 있습니다.
```

`Object.assign`을 사용하는 방법도 있다.

```jsx
Object.assign(dest, [src1, src2, src3...]);
```

- `dest`는 목표 객체다.
- 이어지는 인수 `src...`은 복사하고자 하는 객체다.
- `src...`의 프로퍼티를 `dest`에 복사한다. `dest`를 제외한 인수(객체)의 프로퍼티 전부가 첫 번째 인수(객체)로 복사된다.
- 목표 객체에 동일한 이름을 가진 프로퍼티가 있는 경우엔 값이 덮어씌워진다.
- `dest`를 반환한다.

e.g.,

```jsx
let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// permissions1과 permissions2의 프로퍼티를 user로 복사합니다.
Object.assign(user, permissions1, permissions2);

// now user = { name: "John", canView: true, canEdit: true }
```

```jsx
let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);
```

### 중첩 객체 복사

프로퍼티가 다른 객체에 대한 참조값이라면 어떻게 복사할 수 있을까?

이 문제를 해결하려면 각 키 값을 검사하면서, 그 값이 객체인 경우 객체의 구조도 복사해주는 반복문을 사용해야 한다. 이런 방식을 '깊은 복사(deep cloning)'라고 한다.

깊은 복사 시 사용되는 표준 알고리즘인 [Structured cloning algorithm](https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data)을 사용하면 위 사례를 비롯한 다양한 상황에서 객체를 복제할 수 있다.

자바스크립트 라이브러리 [lodash](https://lodash.com/)의 메서드인 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)을 사용하면 이 알고리즘을 직접 구현하지 않고도 깊은 복사를 처리할 수 있다.

# 4.3 가비지 컬렉션

자바스크립트는 눈에 보이지 않는 곳에서 메모리 관리를 수행한다. 자바스크립트 엔진이 어떻게 필요 없는 것을 찾아내 삭제할까?

### 가비지 컬렉션 기준

자바스크립트는 도달 가능성(reachability)라는 개념을 사용해 메모리 관리를 수행한다. 도달 가능하다는 것은 어떻게든 접근하거나 사용할 수 있는 값이라는 뜻이다. 도달 가능한 값을 메모리에서 삭제되지 않는다.

아래 값들은 태생부터 도달 가능하기 때문에, 명백한 이유가 없으면 삭제되지 않는다.

- 현재 함수의 지역 변수와 매개변수
- 중첩 함수의 체인에 있는 함수에서 사용되는 변수의 매개변수
- 전역 변수

이런 값들은 루트라고 부른다.

루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.

자바스크립트 엔진 내에서 가비지 컬렉터가 끊임없이 동작하여 모든 객체를 모니터링 한다. 도달할 수 없는 객체는 삭제된다.

### 도달할 수 없는 섬

### 내부 알고리즘

'mark-and-sweep'이라 불리는 가비지 컬렉션 기본 알고리즘.

가비지 컬렉션은 대게 다음 단계를 거쳐 수행된다.

- 가비지 컬렉터는 루트 정보를 수집하고 이를 기억(mark)한다.
- 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 mark한다.
- mark된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 mark한다. 한 번 방문한 객체는 전부 mark하기 때문에 재방문하는 일은 없다.
- 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복한다.
- mark되지 않은 모든 객체를 메모리에서 삭제한다.

자바스크립트 엔진은 실행에 영향을 미치지 않으면서 가비지 컬렉션을 더 빠르게 하는 다양한 최적화 기법을 적용한다. 

- 세대별 수집: 새로운 객체와 오래된 객체(덜 감시)로 나누어 감시
- 점진적 수집: 가비지 컬렉션을 여러 부분으로 분리하여 관리
- 유휴 시간 수집: CPU가 idle일 때만 가비지 컬렉션을 실행

# 4.4 메서드와 this

객체는