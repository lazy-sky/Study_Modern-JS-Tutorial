# 5.1 원시값의 메서드

자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다. 원시값에서도 객체에서처럼 메소드를 호출할 수 있다. 

### 원시값을 객체처럼 사용하기

객체는 원시값에 비해 여러 장점을 갖는다. 하지만 그 기능들을 사용하면 시스템 자원이 많이 소모된다는 단점이 있다. 

문자열이나 숫자와 같은 원시값을 다루어야 하는 작업이 많은데, 메서드를 사용하면 작업을 수월하게 할 수 있음과 동시에 원시값은 가능한 한 빠르고 가벼워야 한다. 자바스크립트의 창안자는 아래와 같은 방법으로 이 모순을 해결하려 하였다.

1. 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지한다.
2. 문자열, 숫자, 불린, 심볼의 메소드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용한다.
3. 이를 가능하게 하기 위해 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, 원시 래퍼 객체를 만들어준다. 이 객체는 곧 삭제된다.
    1. 각 래퍼 객체는 원시 자료형의 이름을 그대로 차용해, `String`, `Number`, `Boolean`, `Symbol`이라 부른다.

# 5.2 숫자형

자바스크립트엔 두 종류의 숫자형이 있다.

64비트로 표현하는 일반적이 숫자와 아주 크거나 작은 숫자를 표시하는 Bigint

### 숫자를 입력하는 다양한 방법

- `e`는 왼쪽의 수에 오른쪽에 있는 수만큼의 10의 거듭제곱을 곱하는 효과가 있다.

```jsx
let billion = 1e9;  // 10억, 1과 9개의 0
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
```

- 16진수 - `0x`, 2진수 - `0b`, 8진수 - `0o`

```jsx
alert( 0xff ); // 255
let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수
alert( a === b ); // true, 진법은 다르지만, a와 b는 같은 수임
```

이 외의 진법은 `parseInt`를 사용한다.

### toString(base)

`num.toString(base)` 메서드는 `base` 진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환한다.

### 어림수 구하기

- `Math.floor` - 내림
- `Math.ceil` - 올림
- `Math.round` - 반올림
- `Math.trunc` - 소수부 무시(내림과 다름)

### 부정확한 계산

숫자가 너무 커지면 64비트 공간이 넘쳐 Infinity로 처리된다.

정밀도 손실도 있다. 왜 이러는 걸까?

```jsx
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

숫자는 이진수로 변환되어 연속된 메모리 공간에 저장된다. 그런데 10진법으로 쉽게 표현되는 분수는 이진법으로 표현하면 무한 소수가 된다. 이진법에서 0.1이나 0.2를 정확하게 저장하는 방법은 없다. 그리고 두 숫자를 합하면 정밀도 손실도 더해진다.

이 문제를 해결할 가장 신뢰할만한 방법은 `toFixed(n)` 메소드를 사용해 어림수를 만드는 것이다.

```jsx
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

`toFixed`는 항상 문자열을 반환한다. 그래서 소수점 다음에 숫자가 항상 2개가 될 수 있다. 다시 숫자형으로 바꾸러면 단항 덧셈 연산자를 사용하면 된다.