# 5.1 원시값의 메서드

자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다. 원시값에서도 객체에서처럼 메소드를 호출할 수 있다. 

### 원시값을 객체처럼 사용하기

객체는 원시값에 비해 여러 장점을 갖는다. 하지만 그 기능들을 사용하면 시스템 자원이 많이 소모된다는 단점이 있다. 

문자열이나 숫자와 같은 원시값을 다루어야 하는 작업이 많은데, 메서드를 사용하면 작업을 수월하게 할 수 있음과 동시에 원시값은 가능한 한 빠르고 가벼워야 한다. 자바스크립트의 창안자는 아래와 같은 방법으로 이 모순을 해결하려 하였다.

1. 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지한다.
2. 문자열, 숫자, 불린, 심볼의 메소드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용한다.
3. 이를 가능하게 하기 위해 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, 원시 래퍼 객체를 만들어준다. 이 객체는 곧 삭제된다.
    1. 각 래퍼 객체는 원시 자료형의 이름을 그대로 차용해, `String`, `Number`, `Boolean`, `Symbol`이라 부른다.

# 5.2 숫자형

자바스크립트엔 두 종류의 숫자형이 있다.

64비트로 표현하는 일반적이 숫자와 아주 크거나 작은 숫자를 표시하는 Bigint

### 숫자를 입력하는 다양한 방법

- `e`는 왼쪽의 수에 오른쪽에 있는 수만큼의 10의 거듭제곱을 곱하는 효과가 있다.

```jsx
let billion = 1e9;  // 10억, 1과 9개의 0
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
```

- 16진수 - `0x`, 2진수 - `0b`, 8진수 - `0o`

```jsx
alert( 0xff ); // 255
let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수
alert( a === b ); // true, 진법은 다르지만, a와 b는 같은 수임
```

이 외의 진법은 `parseInt`를 사용한다.

### toString(base)

`num.toString(base)` 메서드는 `base` 진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환한다.

### 어림수 구하기

- `Math.floor` - 내림
- `Math.ceil` - 올림
- `Math.round` - 반올림
- `Math.trunc` - 소수부 무시(내림과 다름)

### 부정확한 계산

숫자가 너무 커지면 64비트 공간이 넘쳐 Infinity로 처리된다.

정밀도 손실도 있다. 왜 이러는 걸까?

```jsx
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

숫자는 이진수로 변환되어 연속된 메모리 공간에 저장된다. 그런데 10진법으로 쉽게 표현되는 분수는 이진법으로 표현하면 무한 소수가 된다. 이진법에서 0.1이나 0.2를 정확하게 저장하는 방법은 없다. 그리고 두 숫자를 합하면 정밀도 손실도 더해진다.

이 문제를 해결할 가장 신뢰할만한 방법은 `toFixed(n)` 메소드를 사용해 어림수를 만드는 것이다.

```jsx
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

`toFixed`는 항상 문자열을 반환한다. 그래서 소수점 다음에 숫자가 항상 2개가 될 수 있다. 다시 숫자형으로 바꾸러면 단항 덧셈 연산자를 사용하면 된다.
### isNaN과 isFinite

두 특수 숫자는 숫자형에 속하지만 정상적인 숫자는 아니기 때문에 정상적인 숫자와 구분하기 위한 특별한 함수가 존재한다.

- `isNaN(value)` - 인수를 숫자로 변환한 다음 `NaN`인지 테스트
- `isFinite(value)` - 인수를 숫자로 변환하고 변환한 숫자가 `Nan/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환

### paeseInt와 parseFloat

덧셈 연산자 `+` 또는 `Number()`를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격하다. 피연산자가 숫자가 아니면 형변환이 실패한다.

하지만 실무에선 `100px`, `12pt`, `4$` 처럼 숫자와 단위를 함께 쓰는 경우가 흔하다. 두 내장함수는 이런 경우를 위해 만들어졌다. 두 함수는 불가능할 때까지 문자열에서 숫자를 읽는다. 도중 오류가 발생하면 이미 수집된 숫자를 반환한다.

```jsx
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, 정수 부분만 반환됩니다.
alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춥니다.

alert( parseInt('a123') ); // NaN, a는 숫자가 아니므로 숫자를 읽는 게 중지됩니다.
```

### 기타 수학 함수

- `Math.random()`
- `Math.max(a, b, c...)`
- `Math.pow(n, power)`

# 5.3 문자열

### 따옴표

- 작은따옴표
- 큰따옴표
- 백틱: 표현식을 문자열 중간에 삽입할 수 있다. (템플릿 리터럴)

### 특수 기호

줄 바꿈 문자(`\n`)를 비롯하여 다양한 특수 기호들이 있다.

### 특정 글자에 접근하기

```jsx
let str = `Hello`;

// 첫 번째 글자
alert( str[0] ); // H
alert( str.charAt(0) ); // H, 다만 charAt은 하위 호환성을 위해 남아있는 메서드다.

// 마지막 글자
alert( str[str.length - 1] ); // o

// 두 접근 방식의 차이는 반환할 글자가 없을 때 드러난다.
alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // '' (빈 문자열)
```

### 문자열의 불변성

문자열은 수정할 수 없다. 중간 글자 하나를 바꾸려고 하면 에러가 발생한다.

### 부분 문자열 찾기

- `str.indexOf`

```jsx
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, str은 'Widget'으로 시작함
alert( str.indexOf('widget') ); // -1, indexOf는 대·소문자를 따짐

alert( str.indexOf("id") ); // 1, "id"는 첫 번째 위치에서 발견됨 (Widget에서 id)
```

`str.indexOf(substr, pos)`의 두 번째 매개변수 `pos`는 선택적으로 사용할 수 있는데, 이를 명시하면 검색이 해당 위치부터 시작된다.

```jsx
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
```

문자열 내 부분 문자열 전체를 대상으로 무언가를 하고 싶다면 반복문 안에 `indexOf`를 사용하면 된다. 반복문이 하나씩 돌 때마다 검색 시작 위치가 갱신되면서 `indexOf`가 새롭게 호출된다.

```jsx
let str = "As sly as a fox, as strong as an ox";
let target = "as";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( `위치: ${pos}` );
}
```

`if`문의 조건식에 `indexOf`를 쓸 때 주의할 점이 있다. `str.indexOf("Widget")`은 `0`을 반환하는데, `if`문에선 `0`을 `false`로 간주하므로 `alert` 창이 뜨지 않는다. 따라서 부분 문자열 여부를 검사하려면 아래와 같이 `-1`과 비교해야 한다.

- 비트 NOT 연산자 사용한 기법

언어 특유의 기능을 사용해 직관적이지 않은 코드이기 때문에 추천되는 작성법은 아니다. 하지만 오래된 스크립트에서 쉽게 만날 수 있기 때문에 알아두어야 한다.

```jsx
alert( ~2 ); // -3, -(2+1)과 같음
alert( ~1 ); // -2, -(1+1)과 같음
alert( ~0 ); // -1, -(0+1)과 같음
alert( ~-1 ); // 0, -(-1+1)과 같음
```

- `includes`, `startsWith`, `endsWith`

`str.includes(substr, pos)`는 `str`에 부분 문자열 `substr`이 있는지에 따라 `true`나 `false`를 반환한다. 부분 문자열의 위치 정보는 필요하지 않고 포함 여부만 알고 싶을 때 적합하다. `str.includes`에도 `str.indexOf`처럼 두 번째 인수를 넘기면 해당 위치부터 부분 문자열을 검색한다.

`str.startsWith`와 `str.endsWith`는 메서드 이름 그대로 문자열 `str`이 특정 문자열로 시작하는지 여부와 특정 문자열로 끝나는지 여부를 확인할 때 사용할 수 있다.

### 부분 문자열 추출하기

- `str.slice(start, [, end])`
    - 문자열의 `start`부터 `end` 전까지를 반환한다.
    - 두 번째 인수가 생략된 경우엔 문자열 끝까지를 반환한다.
    - 음수를 넘기면 문자열 끝에서부터 카운팅한다.
- `str.substring(start, [, end])`
    - `start`와 `end` 사이에 있는 문자열을 반환한다.
    - 음수 인수를 허용하지 않는다. 음수는 0으로 처리한다.
    - `slice`와 달리 `start`보다 `end`가 커도 된다.
- `str.substr(start, [, length])`
    - `start`부터 `length` 개의 글자를 반환한다.
    - 첫 번째 인수가 음수면 뒤에서부터 개수를 센다.

### 문자열 비교하기

기본적으론 알파벳 순서를 기준으로 글자끼리 비교된다.

소문자는 항상 대문자보다 크다.

발음 구별 기호가 붙은 문자는 알파벳 순서 기준을 따르지 않는다.

# 5.4 배열

### 배열의 내부 동작 원리

배열은 특별한 종류의 객체다. 배열 `arr`의 요소를 `arr[0]`처럼 대괄호를 사용해 접근하는 방식은 객체 문법에서 왔다. 다만 **배열은 키가 숫자**라는 점이 다르다.

숫자형 키를 사용함으로써 배열은 객체 기본 기능 이외에도 순서가 있는 컬렉션을 제저하게 해주는 특별한 메서드를 제공한다. 그렇지만 어쨌든 **배열의 본질은 객체**다. 따라서 객체처럼 동작한다.

배열을 배열답게 만들어주는 것은 특수 내부 표현방식이다. 자바스크립트 엔진은 배열의 요소를 인접한 메모리 공간에 차례로 저장해 연산 속도를 높인다. 이 외에도 배열 관련 연산을 더 빠르게 해주는 최적화 기법은 다양하다. 그런데 개발자가 배열을 순서가 있는 자료의 컬렉션처럼 다루지 않고 일반 객체처럼 다루면 이런 기법들이 제대로 작동하지 않는다.

```jsx
let arr = []; 

arr[99999] = 5; // 배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만듭니다.
arr.age = 25; // 임의의 이름을 사용해 프로퍼티를 만듭니다.
```

배열은 객체이므로 원하는 프로퍼티를 추가해도 문제가 발생하지 않는다. 하지만 이렇게 하면 자바스크립트 엔진이 배열을 일반 객체처럼 다루게 되어 배열을 다룰 때만 적용되는 최적화 기법이 동작하지 않나 배열 특유의 이점이 사라진다.

### 성능

`push`와 `pop`은 빠르지만 `shift`와 `unshift`는 느리다.

### 반복문

`for`, `for..of`를 사용해서 배열을 순회할 수 있다. 배열은 객체형에 속하므로 `for..in`을 사용하는 것도 가능하다. 하지만 다음과 같은 문제로 되도록 사용하지 않는 것이 좋다.

- `for..in` 반복문은 모든 프로퍼티를 대상으로 순회한다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다. 유사 배열 객체엔 배열과 달리 키가 숫자형이 아닌 프로퍼티와 메서드가 있을 수도 있다.
- `for..in` 반복문은 배열이 아니라 객체와 함께 사용할 때 최적화되어 있어 배열에 사용하면 객체 대비 10배 이상 느리다.

### length 프로퍼티

배열에 무언가 조작을 가하면 `length` 프로퍼티가 자동으로 갱신된다. `length` 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값이다.

또 다른 독특한 특징 중 하나는 쓰기가 가능하다는 점이다. `length`의 값을 수동으로 증가시키면 아무 일도 일어나지 않는다. 그런데 감소시키면 배열이 잘린다. 짧아진 배열은 다시 되돌릴 수 없다. 이런 특징을 이용하면 `arr.length = 0;`을 이용해 아주 간단하게 배열을 비울 수 있다.

### new Array()

대괄호를 사용하면 더 짧은 문법으로 배열을 만들 있기 때문에 잘 사용되지 않는 편이다. 숫자형 인수 하나를 넣어 `new Array`를 호출하면 배열이 만들어지는데, 이 배열엔 요소가 없는 반면 길이는 인수와 같아진다. 이때 요소들은 모두 `undefined`다. 이런 뜻밖의 상황을 피하기 위해 대괄호를 써서 배열을 만든다.

### 다차원 배열

배열 역시 배열의 요소가 될 수 있다. 이런 배열을 다차원 배열이라 부른다. 다차원 배열은 행렬을 저장하는 용도로 쓰인다.

### toString

배열엔 `toString` 메서드가 구현되어 있어 요소를 쉼표로 구분한 문자열을 반환하게 할 수 있다.

```jsx
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```

# 5.5 배열과 메서드

### 요소 추가, 제거 메서드

**push, pop, shift, unshift**

**splice**

배열 역시 객체형에 속하므로 프로퍼티를 지울 때 쓰는 연산자 `delete`를 쓰면 요소 하나를 지울 수 있다.

```jsx
let arr = ["I", "go", "home"];

delete arr[1]; // "go"를 삭제합니다.

alert( arr[1] ); // undefined

// delete를 써서 요소를 지우고 난 후 배열 --> arr = ["I",  , "home"];
alert( arr.length ); // 3
```

그런데 요소를 지운 후에도 `length`는 변함이 없다. 왜냐하면 `delete obj.key`는 해당 키에 상응하는 값을 지우기 때문이다. (빈 공간을 나머지 요소들이 자동으로 채울 것이라 기대했지만 그렇지 않다.)

이런 기대를 충족하는 게 `arr.splice(start)`다. 이 메소드를 사용하면 요소 추가, 삭제, 교체가 모두 가능하다.

```jsx
arr.splice(index[, deleteCount, elem1, ..., elemN])
```

- 첫 번째 매개변수는 조작을 가할 첫 번째 요소를 가리키는 인덱스다. 음수 인덱스도 사용할 수 있다.
- 두 번째 매개변수는 제거하고자 하는 요소의 개수를 나타낸다.
- 이후 매개변수들은 배열에 추가할 요소들을 나타낸다. `deleteCount`를 `0`으로 하면 요소를 제거하지 않으면서 새로운 요소를 추가할 수 있다.

**slice**

```jsx
arr.slice([start], [end])
```

`start` 인덱스부터 `end` 전 인덱스까지 요소를 복사한 새로운 배열을 반환한다.

**concat**

기존의 배열 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가하고자 할 때 사용한다. 인수엔 배열이나 값이 올 수 있다.

```jsx
arr.concat(arg1, arg2...)
```

**forEach**

주어진 함수를 배열 요소 각각에 대해 실행할 수 있게 해준다.

### 배열 탐색하기

**indexOf, lastIndexOf, includes**

셋은 같은 이름을 가진 문자열 메소드와 하는 일과 문법이 동일하다.

**find와 findIndex**

객체로 이루어진 배열이 있다고 할 때, 특정 조건에 부합하는 객체를 배열 내에서 찾고 싶다면 `arr.find(fn)`을 사용할 수 있다.

```jsx
let result = arr.find(function(item, index, array) {
  // true가 반환되면 반복이 멈추고 해당 요소를 반환합니다.
  // 조건에 해당하는 요소가 없으면 undefined를 반환합니다.
});
```

요소 전체를 대상으로 함수가 순차적으로 호출된다.

- `item` – 함수를 호출할 요소, 사실 아래 두 인자는 잘 사용되지 않는다.
- `index` – 요소의 인덱스
- `array` – 배열 자기 자신

함수가 참을 반환하면 탐색은 중단되고 해당 `요소`가 반환, 원하는 요소를 찾지 못하면 `undefined`가 반환된다.

e.g.,

```jsx
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```

`arr.findIndex`는 find와 동일한 일을 하나, 조건에 맞는 요소를 반환하는 대신 해당 요소의 인덱스를 반환한다는 점이 다르다. 조건에 맞는 요소가 없으면 -1 반환.

**filter**

`find`는 함수의 반환 값을 `true`로 만드는 단 하나의 요소를 찾는다. 조건을 충족하는 요소가 여러 개라면 `filter`를 사용하면 된다. `filter`와 `find`는 문법이 유사하지만 조건에 맞는 요소 전체를 담은 배열을 반환한다는 점에서 차이가 있다.

### 배열을 변형하는 메서드

**map**

배열 요소 전체를 대상을 함수를 호출하고, 함수 호출 결과를 배열로 반환해준다.

**sort(fn)**

배열의 요소를 정렬해준다. 배열 자체가 변경된다. 메서드를 호출하면 재정렬된 배열이 반환되는데, 이미 배열 자체가 수정되었기 때문에 반환 값은 잘 사용되지 않는 편이다.

요소는 문자열로 취급되어 정렬된다. 기존 정렬 기준 대신 새로운 정렬 기준을 만들려면 인수로 새로운 함수를 넘겨줘야 한다. 인수로 넘겨주는 함수는 반드시 값 두 개를 비교해야 하고 반환 값도 있어야 한다.

**reverse**

요소를 역순으로 정렬시켜준다. 반환 값은 재정렬된 배열이다.

**split과 join**

`split`은 구분자(첫 번째 인자)를 기준으로 문자열을 쪼개준다. 두 번째 인수로 숫자를 받을 수 있는데, 이 숫자는 배열의 길이를 제한해주어 길이를 넘어서는 요소를 무시할 수 있다.

```jsx
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```

인자를 넣지 않으면 문자열을 글자 단위로 쪼갤 수 있다.

`join`은 `split`과 반대 역할을 하는 메서드다.

```jsx
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // 배열 요소 모두를 ;를 사용해 하나의 문자열로 합칩니다.

alert( str ); // Bilbo;Gandalf;Nazgul
```

### reduce와 reduceRight

배열을 기반으로 값 하나를 도출할 때 사용된다.

```jsx
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```

인수로 넘겨주는 함수는 배열의 모든 요소를 대상으로 차례차례 적용되는데, 적용 결과는 다음 함수 호출 시 사용된다.

- `accumulator` – 이전 함수 호출의 결과.
- `item` – 현재 배열 요소
- `index` – 요소의 위치
- `array` – 배열
- `initial` - 함수 최초 호출 시 사용되는 초기값, 없으면 배열의 첫 번째 요소를 초기값으로 사용하고 두 번째 요소부터 함수를 호출한다. 항상 초기값을 명시해줄 것이 권장된다.

이전 함수 호출 결과는 다음 함수를 호출할 때 첫 번째 인수(`previousValue`)로 사용된다.

첫 번째 인수는 앞서 호출했던 함수들의 결과가 누적되어 저장되는 '누산기(accumulator)'라고 생각하면 된다. 마지막 함수까지 호출되면 이 값은 `reduce`의 반환 값이 된다.

`reduceRight`는 완전히 동일하지만 배열의 오른쪽부터 연산을 수행한다.

### Array.isArray로 배열 여부 알아내기

자바스크립트에서 배열은 독립된 자료형으로 취급되지 않고 객체형에 속한다. 따라서 `typeof`로는 일반 객체와 배열을 구분할 수가 없다. 그래서 해당 메소드를 사용한다.

```jsx
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true
```

### 배열 메서드와 'thisArg'

함수를 호출하는 대부분의 배열 메서드는 `thisArg`라는 매개변수를 옵션으로 받을 수 있다. 자주 사용되는 인수는 아니다.

```jsx
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg는 선택적으로 사용할 수 있는 마지막 인수입니다.
```

`thisArg`는 `func`의 `this`가 된다.

# 5.6 iterable 객체

반복가능한 객체는 배열을 일반화한 객체다. 이터러블이라는 개념을 사용하면 어떤 객체에든 `for..of`를 사용할 수 있다. 배열은 대표적인 이터러블이다. 배열 외에도 다수의 내장 객체가 반복 가능하다. 문자열 역시 이터러블의 예다.

배열이 아닌 객체를 어떤 것들의 컬렉션으로 나타내고 있는 경우, `for..of` 문법을 적용할 수 있다면 순회에 유용할 것이다.

### Symbol.iterator

```jsx
let range = {
  from: 1,
  to: 5
};

// 아래와 같이 for..of가 동작할 수 있도록 하는 게 목표입니다.
// for(let num of range) ... num=1,2,3,4,5
```

`range`를 이터러블로 만들려면(`for..of`가 동작하도록 하려면) 객체에 `Symbol.iterator`(특수 내장 심볼)라는 메서드를 추가해 아래와 같은 일이 벌어지도록 해야 한다.

1. `for..of`가 시작되자마자 `for..of`는 `Symbol.iterator`를 호출한다(`Symbol.iterator`가 없으면 에러 발생). `Symbol.iterator`는 반드시 *이터레이터(iterator, 메서드 `next`가 있는 객체)* 를 반환해야 한다.
2. 이후 `for..of`는 *반환된 객체(이터레이터)만*을 대상으로 동작한다.
3. `for..of`에 다음 값이 필요하면, `for..of`는 이터레이터의 `next()`메서드를 호출한다.
4. `next()`의 반환 값은 `{done: Boolean, value: any}`와 같은 형태이어야 한다. `done=true`는 반복이 종료되었음을 의미한다. `done=false`일땐 `value`에 다음 값이 저장된다.

```jsx
let range = {
  from: 1,
  to: 5
};

// 1. for..of 최초 호출 시, Symbol.iterator가 호출
range[Symbol.iterator] = function() {

  // Symbol.iterator는 이터레이터 객체를 반환
  // 2. 이후 for..of는 반환된 이터레이터 객체만을 대상으로 동작하는데, 이때 다음 값도 결정
  return {
    current: this.from,
    last: this.to,

    // 3. for..of 반복문에 의해 반복마다 next()가 호출
    next() {
      // 4. next()는 값을 객체 {done:.., value :...}형태로 반환해야 함
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// 이제 의도한 대로 동작!
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```

이터러블 객체의 핵심은 '관심사의 분리(Separation of concern, SoC)'에 있다.

- `range`엔 메서드 `next()`가 없다.
- 대신 `range[Symbol.iterator]()`를 호출해서 만든 ‘이터레이터’ 객체와 이 객체의 메서드 `next()`에서 반복에 사용될 값을 만들낸다.

이렇게 하면 이터레이터 객체와 반복 대상인 객체를 분리할 수 있다.

### 문자열은 이터러블

배열과 문자열은 가장 광범위하게 쓰이는 내장 이터러블이다. 

`for..of`는 문자열의 각 글자를 순회한다.

### 이터레이터과 유사 배열

- 이터러블은 메서드 `Symbol.iterator`가 구현된 객체다.
- 유사 배열은 인덱스와 `length` 프로퍼티가 있어서 배열처럼 보이는 객체다.

브라우저나 등의 호스트 환경에서 자바스크립트를 사용해 문제를 해결할 때 이터러블 객체나 유사 배열 객체 혹은 둘 다인 객체를 만날 수 있다. 이터러블 객체(`for..of` 를 사용할 수 있음)이면서 유사배열 객체(숫자 인덱스와 `length` 프로퍼티가 있음)인 문자열이 대표적인 예다.

이터러블 객체라고 해서 유사 배열 객체는 아니다. 유사 배열 객체라고 해서 이터러블 객체인 것도 아니다.

이터러블과 유사 배열은 대개 배열이 아니기 때문에`push`, `pop` 등의 메서드를 지원하지 않는다. 이터러블과 유사 배열을 배열처럼 다루고 싶을 때 이런 특징은 불편함을 초래한다. 

### Arrray.from

범용 메서드 `Array.from`은 이터러블이나 유사 배열을 진짜 배열로 만들어준다.

```jsx
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); 
// 객체를 받아 이터러블이나 유사 배열인지 조사한다. 
// 맞으면 새로운 배열을 만들고 객체의 모든 요소를 새롭게 만든 배열로 복사한다.
alert(arr.pop()); // World (메서드가 제대로 동작합니다.)
```

`Array.from`엔 매핑 함수를 선택적으로 넘겨줄 수 있다.

```jsx
Array.from(obj[, mapFn, thisArg])
```

`mapFn`을 두 번째 인수로 넘겨주면 새로운 배열에 `obj`의 요소를 추가하기 전에 각 요소를 대상으로 `mapFn`을 적용할 수 있다. 새로운 배열엔 `mapFn`을 적용하고 반환된 값이 추가된다. 세 번째 인수 `thisArg`는 각 요소의 `this`를 지정할 수 있도록 해준다.

e.g.,

```jsx
// range는 챕터 위쪽 예시에서 그대로 가져왔다고 가정

// 각 숫자를 제곱
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
```

# 5.7 맵과 셋

### 맵

키가 있는 데이터를 저장한다는 점에서 객체와 유사핟. 다만 맵은 키에 다양한 자료형을 허용한다는 차이가 있다.

**주요 프로퍼티**

- `new Map()` – 맵을 만듭니다.
- `map.set(key, value)` – `key`를 이용해 `value`를 저장합니다.
- `map.get(key)` – `key`에 해당하는 값을 반환합니다. `key`가 존재하지 않으면 `undefined`를 반환합니다.
- `map.has(key)` – `key`가 존재하면 `true`, 존재하지 않으면 `false`를 반환합니다.
- `map.delete(key)` – `key`에 해당하는 값을 삭제합니다.
- `map.clear()` – 맵 안의 모든 요소를 제거합니다.
- `map.size` – 요소의 개수를 반환합니다.

```jsx
let map = new Map();

map.set('1', 'str1');   // 문자형 키
map.set(1, 'num1');     // 숫자형 키
map.set(true, 'bool1'); // 불린형 키

// 객체는 키를 문자형으로 변환한다는 걸 기억하고 계신가요?
// 맵은 키의 타입을 변환시키지 않고 그대로 유지합니다. 따라서 아래의 코드는 출력되는 값이 다릅니다.
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
```